---
title: Prog Tut06-2
date: 2024-09-08 14:20:00 +0200
categories: [Prog, Tut06]
tags: [Prog]
render_with_liquid: false
typora-root-url: ../


---

# Abstrakte Klassen und Traits

---

## was ist Tratis ? 

**Scala**에서 **재사용 가능한 코드**를 정의하기 위한 중요한 구성 요소 중 하나입니다. 

Tratis 는 **자바의 인터페이스(Interface)**와 유사하지만, 더 많은 기능을 제공합니다. 

**여러 클래스에서 공통적으로 사용되는 로직**을 정의할 때 유용합니다. 

**다중 상속**과 비슷한 개념이지만, **트레이트는 더 유연**합니다.

트레이트는 **추상 메서드**와 **구체적인 메서드**를 모두 포함할 수 있으며, 상태(필드)를 가질 수도 있습니다.



1. Bietet mehr Funktionalität als Interface in Java.
2.  Nützlich für die Definition von Logik, die für mehrere Klassen gleich ist. 
3. Ähnlich wie Mehrfachvererbung, aber Traits sind flexibler.



---

## Eigenheiten

1. Unterstützung für **Mehrfachvererbung**
2. Es sind sowohl **konkrete Implementierungen** als auch **abstrakte Methoden** möglich

```scala
trait Animal {
  def sound(): String  // 추상 메서드
  def breathe(): String = "Breathing..."  // 구체 메서드
}

class Dog extends Animal {
  def sound(): String = "Bark"
}

val dog = new Dog
println(dog.sound())  // Bark
println(dog.breathe())  // Breathing...

```

3. **kann auch einen Status (Feld)** haben
4. Sie können **keine Instanzen direkt erstellen** (반드시 **클래스에서 믹스인**)

---

## **Traits 추상 클래스의 차이** :

- **Traits 는 다중 상속을 지원하며, **다양한 클래스에 동일한 기능을 적용**하고 싶을 때 사용합니다.
- **추상 클래스**는 상태(필드)와 추상 메서드가 필요할 때 사용되며, 주로 **하나의 클래스 계층 구조**에서 공통 로직을 공유할 때 사용됩니다.
- **Traits 는 생성자 매개변수를 가질 수 없지만**, 추상 클래스는 생성자 매개변수를 가질 수 있습니다.

---

### **트레이트(Trait)란?**

**트레이트(Trait)**는 **Scala**에서 **재사용 가능한 코드**를 정의하기 위한 중요한 구성 요소 중 하나입니다. 트레이트는 **자바의 인터페이스(Interface)**와 유사하지만, 더 많은 기능을 제공합니다. **여러 클래스에서 공통적으로 사용되는 로직**을 정의할 때 유용합니다. **다중 상속**과 비슷한 개념이지만, **트레이트는 더 유연**합니다.

트레이트는 **추상 메서드**와 **구체적인 메서드**를 모두 포함할 수 있으며, 상태(필드)를 가질 수도 있습니다.

------

### **트레이트의 주요 특징**

1. **트레이트는 다중 상속을 지원**:

   - **여러 트레이트**를 하나의 클래스에 믹스인할 수 있습니다. 즉, Scala에서는 하나의 클래스가 여러 트레이트로부터 상속받아 **다중 상속**처럼 사용할 수 있습니다.

   ```scala
   
   trait TraitA {
     def methodA(): Unit = println("Method A")
   }
   
   trait TraitB {
     def methodB(): Unit = println("Method B")
   }
   
   class MyClass extends TraitA with TraitB
   
   val obj = new MyClass
   obj.methodA()  // Method A
   obj.methodB()  // Method B
   ```

2. **구체적인 구현과 추상 메서드 모두 가능**:

   - 트레이트는 **구체적인 메서드**(이미 구현된 메서드)와 **추상 메서드**(구현되지 않은 메서드)를 동시에 가질 수 있습니다.
   - 이는 자바의 인터페이스와 다른 점으로, 자바의 인터페이스는 구현을 포함할 수 없지만, Scala 트레이트는 **구현을 포함**할 수 있습니다.

   ```scala
   
   trait Animal {
     def sound(): String  // 추상 메서드
     def breathe(): String = "Breathing..."  // 구체 메서드
   }
   
   class Dog extends Animal {
     def sound(): String = "Bark"
   }
   
   val dog = new Dog
   println(dog.sound())  // Bark
   println(dog.breathe())  // Breathing...
   ```

3. **상태(필드)도 가질 수 있다**:

   트레이트는 **필드**를 가질 수 있습니다. 이는 트레이트가 **객체의 상태**를 관리하는 데에도 사용할 수 있음을 의미합니다.

   ```scala
   
   trait HasAge {
     var age: Int = 0
     def incrementAge(): Unit = age += 1
   }
   
   class Person extends HasAge
   
   val person = new Person
   person.incrementAge()
   println(person.age)  // 1
   ```

4. **트레이트는 인스턴스를 직접 생성할 수 없다**:

   - 트레이트는 추상 클래스처럼 **인스턴스를 직접 생성**할 수 없습니다. 반드시 **클래스에서 믹스인**되어야 합니다.
   - 트레이트는 **구현할 의무가 없는 추상적인 부분**을 포함할 수 있기 때문에, 이를 직접 사용할 수 없고 **구현체가 필요**합니다.

   ```scala
   trait Greeter {
     def greet(): Unit
   }
   
   // 인스턴스화 불가:
   // val greeter = new Greeter  // 오류 발생
   ```

5. **트레이트와 클래스의 차이**:

   - 트레이트는 클래스와 다르게 **다중 상속**이 가능하며, **상속 구조 외부에서도 기능을 믹스인**할 수 있습니다.
   - 한 클래스는 여러 트레이트를 상속받을 수 있지만, 여러 클래스를 상속받을 수는 없습니다.
   - 또한, 클래스와 달리 **트레이트는 생성자 인자를 가질 수 없습니다**. 생성자 매개변수가 필요한 경우 추상 클래스를 사용하는 것이 일반적입니다.

   

6. **트레이트는 믹스인(mixin) 방식으로 사용 가능**:

   - **믹스인**은 트레이트를 클래스에 **혼합**하여 그 트레이트가 가진 기능을 사용할 수 있게 하는 방식입니다.
   - **with** 키워드를 사용하여 **기존 클래스에 트레이트를 추가**할 수 있습니다.

   ```scala
   
   class SimpleClass
   trait FeatureA {
     def featureA(): Unit = println("Feature A")
   }
   
   // 기존 클래스에 트레이트 믹스인
   val instance = new SimpleClass with FeatureA
   instance.featureA()  // Feature A
   ```

7. **트레이트와 추상 클래스의 차이**:

   - **트레이트**는 다중 상속을 지원하며, **다양한 클래스에 동일한 기능을 적용**하고 싶을 때 사용합니다.
   - **추상 클래스**는 상태(필드)와 추상 메서드가 필요할 때 사용되며, 주로 **하나의 클래스 계층 구조**에서 공통 로직을 공유할 때 사용됩니다.
   - **트레이트는 생성자 매개변수를 가질 수 없지만**, 추상 클래스는 생성자 매개변수를 가질 수 있습니다.

------

## **Traits  사용 예시**

```scala

// 두 개의 트레이트 정의
trait Printable {
  def print(): Unit = println("Printing...")
}

trait Saveable {
  def save(): Unit = println("Saving...")
}

// 기존 클래스
class Document

// 믹스인
val doc = new Document with Printable with Saveable
doc.print()  // Printing...
doc.save()   // Saving...

```

위 예시는 **트레이트**를 사용하여 **기존 클래스에 기능을 추가**하는 방법을 보여줍니다.

 `Document` 클래스는 원래 `print()`와 `save()` 메서드를 가지고 있지 않지만, **트레이트 믹스인**을 통해 추가할 수 있습니다.

---

## 결론

트레이트는 **상속 기반의 객체지향 프로그래밍**에서, **다중 상속을 지원**하고, **코드 재사용성과 유연성을 높이기** 위한 중요한 도구입니다. 

**클래스**와 **트레이트**의 역할을 적절히 나누어 사용하면, 보다 **유연하고 유지보수하기 쉬운 코드**를 작성할 수 있습니다.

---





## 예제

### **1. 추상 클래스 `Student` 정의 및 상속**

#### 문제 설명:

- **추상 클래스 `Student`**에는 `study()`라는 추상 메서드가 있습니다.
- 새로운 클래스를 정의하여 이 추상 메서드를 **구현**해야 합니다.

#### 코드:

```scala
abstract class Student {
  def study(): String  // 추상 메서드, 구현되지 않음 (구현 되어있으면 안됨)
}

// Lösung
class Wirtschaftsinformatikstudent extends Student {
  // 추상 메서드를 class 에서 구현
  def study(): String = "Ich studiere Wirtschaftsinformatik an der TUB"
}
```

#### 설명:

- **`abstract class Student`**는 추상 클래스입니다. `study()` 메서드는 **구현 되있으면 안되는 상태**.
- `def` 키워드는 메서드 정의이고, String 타입을 내뱉는것. 즉 뭔가를 프린트 하라는 뜻
- **`Wirtschaftsinformatikstudent` 클래스**는 **`Student`를 상속**받고, `study()` 메서드를 구체적으로 구현.

------

### **2. `Wirtschaft`와 `Informatik` Traits 정의**

#### 문제 설명:

- 두 개의 **트레이트 `Wirtschaft`와 `Informatik`**을 정의하고, 각각 **`learnWirtschaft()`와 `learnInformatik()`** 메서드를 구현합니다.
- 두 메서드는 각각 `"Ich kann Wirtschaft"`와 `"Ich kann Informatik"`을 반환해야 합니다.

#### 코드:

```scala
trait Wirtschaft {
  def learnWirtschaft(): String = "Ich kann Wirtschaft"
}

trait Informatik {
  def learnInformatik(): String = "Ich kann Informatik"
}
```

#### 설명:

- **`trait Wirtschaft`**와 **`trait Informatik`**는 각각 `learnWirtschaft()`와 `learnInformatik()` 메서드를 가지고 있으며, 이 메서드는 각각의 문자열을 반환합니다.
- nämlich in diesem Fall kann man in der `def` eine bestimmte Methode implementieren.

------

### **3. `Wirtschaftsinformatikstudent`에 Traits 추가** (with 키워드 사용)

#### 문제 설명:

- **트레이트 `Wirtschaft`와 `Informatik`**을 **`Wirtschaftsinformatikstudent` 클래스**에 **믹스인**(with)해야 합니다.
- 이로 인해 **traits 메서드**를 사용할 수 있습니다.

#### 코드:

```scala
class Wirtschaftsinformatikstudent extends Student with Wirtschaft with Informatik {
  def study(): String = "Ich studiere Wirtschaftsinformatik"
}
```

#### 설명:

- **`with` 키워드**를 사용하여 **`Wirtschaft`와 `Informatik` 트레이트**를 **믹스인**했습니다. 이제 `Wirtschaftsinformatikstudent` 클래스는 **두 트레이트의 메서드**도 사용할 수 있습니다.

------

### **4. 객체 생성 및 메서드 호출**

#### 문제 설명:

- **`Wirtschaftsinformatikstudent` 클래스의 객체**를 생성하고, **`study`**, **`learnWirtschaft`**, **`learnInformatik`** 메서드를 호출합니다.

#### 코드:

```scala
object Main extends App {
  val student = new Wirtschaftsinformatikstudent

  // 메서드 호출
  println(student.study())            // "Ich studiere Wirtschaftsinformatik"
  println(student.learnWirtschaft())  // "Ich kann Wirtschaft"
  println(student.learnInformatik())  // "Ich kann Informatik"
}
```

#### 설명:

- **`new Wirtschaftsinformatikstudent`**로 객체를 생성하고, `study()`, `learnWirtschaft()`, `learnInformatik()` 메서드를 호출했습니다.
- 각각의 메서드는 클래스 및 트레이트에 구현된 내용을 출력합니다.

------

### **5. 추상 클래스와 트레이트의 차이**

- 추상 클래스

  :

  - **상태(필드)**와 **구현되지 않은 메서드**를 가질 수 있습니다.
  - **한 클래스만 상속**할 수 있습니다.
  - **인스턴스 생성이 불가능**하지만, 다른 클래스에서 상속받아 구체화할 수 있습니다.

- 트레이트

  :

  - **여러 개의 트레이트**를 한 클래스에 믹스인할 수 있습니다.
  - 트레이트는 **상태 없이 메서드**만을 포함할 수 있지만, 상태를 가질 수도 있습니다.
  - 다중 상속이 필요한 상황이나 특정 기능을 여러 클래스에 적용하고자 할 때 유용합니다.

---

## Java Streams

#### (a) **Java Streams의 전통적인 반복문 및 이터레이션에 비해 장점**:

1. **선언적 프로그래밍**: 반복문보다 **읽기 쉽고**, **유지보수가 쉬운 코드**를 작성할 수 있습니다.
2. **병렬 처리 지원**: 스트림은 쉽게 **병렬 처리**가 가능해, 성능을 개선할 수 있습니다.
3. **다양한 API 제공**: 필터링, 매핑, 정렬 등의 **다양한 데이터 처리 작업**을 쉽게 처리할 수 있는 강력한 API를 제공합니다.

#### (b) **Stream과 Collection의 차이**:

1. **Collection**: 데이터를 저장하고 **조직하는 데이터 구조**입니다.
2. **Stream**: 데이터를 **처리하기 위한 파이프라인**을 제공합니다. 데이터를 저장하지 않고, 한 번만 처리하는 방식으로 **선언적**으로 작동합니다.

#### (c) **Intermediäre와 Terminale Operationen의 차이**:

1. **Intermediäre Operationen (중간 연산)**: 스트림을 처리하여 **새로운 스트림을 반환**합니다. 예를 들면 `filter()`, `map()`, `sorted()` 등이 있으며, **지연 평가(lazy evaluation)**로 작동합니다.
2. **Terminale Operationen (종료 연산)**: 스트림을 처리한 후 **결과를 반환**하는 연산입니다. 예를 들면 `collect()`, `forEach()`, `reduce()`가 있으며, **스트림의 처리를 실제로 실행**하는 역할을 합니다.



---

### Z.F

#### (a) **Vorteile von Java Streams im Vergleich zu traditionellen Schleifen**:

1. **Deklarative Programmierung**: Streams ermöglichen lesbaren und wartbaren Code im Vergleich zu herkömmlichen Schleifen.
2. **Parallele Verarbeitung**: Streams unterstützen einfache Parallelisierung und bieten eine potenziell bessere Performance.
3. **Umfangreiche API**: Streams bieten leistungsfähige APIs für Filterung, Transformation und Sortierung von Daten.

#### (b) **Unterschied zwischen einem Stream und einer Collection**:

1. **Collection**: Eine Datenstruktur, die **Daten speichert und organisiert**.
2. **Stream**: Eine **Datenverarbeitungspipeline**, die nicht speichert und deklarativ arbeitet. Streams werden typischerweise nur einmal durchlaufen.

#### (c) **Hauptunterschiede zwischen intermediären und terminalen Operationen**:

1. **Intermediäre Operationen**: Verarbeiten einen Stream und geben **einen neuen Stream** zurück. Beispiele: `filter()`, `map()`, `sorted()`. Diese Operationen sind **lazy**, das heißt, sie werden erst bei einer terminalen Operation ausgeführt.
2. **Terminale Operationen**: Verarbeiten einen Stream und geben **ein Ergebnis** zurück. Beispiele: `collect()`, `forEach()`, `reduce()`. Sie lösen die tatsächliche Verarbeitung des Streams aus.

---

## Stream 예제



````java
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Main {
    private static List<Player> bestPlayers = Player.bestplayers;

    public static void main(String[] args) {
        System.out.println(uniqueTeams(bestPlayers));
        System.out.println(topThreeAssists(bestPlayers));
        System.out.println(mostCommonFirstName(bestPlayers));
        System.out.println(teamsWithBestScoringPlayers(bestPlayers));
        System.out.println(bestScoringTeam(bestPlayers));
    }

    // 6.5.1
    public static long uniqueTeams(List<Player> players) {

        return players.stream()
                .map()

                ;
        //TODO: implement
    }

    // 6.5.2
    public static List<Player> topThreeAssists(List<Player> players) {
        return null;
        //TODO: implement
    }

    // 6.5.3
    public static List<String> mostCommonFirstName(List<Player> players) {
        return null;
        //TODO: implement
    }

    // 6.5.4
    public static List<Map.Entry<String, Long>> teamsWithBestScoringPlayers(List<Player> players) {
        return null;
        //TODO: implement
    }

  // 6.5.5
    public static Map.Entry<String, Integer> bestScoringTeam(List<Player> players) {
        return null;
        //TODO: implement
    }
}

````

````java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Player {
    String name;
    String team;
    int goals;
    int assists;

    public Player(String name, String team, int goals, int assists) {
        this.name = name;
        this.team = team;
        this.goals = goals;
        this.assists = assists;
    }

    @Override
    public String toString() {
        return this.name + " - Goals: " + this.goals + " - Assists: " + this.assists + " - Team: " + this.team;
    }

    static List<Player> bestplayers = new ArrayList<>(Arrays.asList(
            new Player("Ivi López", "Rakow Czestochowa", 20, 7),
            new Player("Mikael Ishak", "Lech Poznan", 18, 6),
            new Player("Karol Angielski", "Radomiak Radom", 18, 1),
            new Player("João Amarai", "Lech Poznan", 14, 8),
            new Player("Lukasz Zwolinski", "Lechia Gdansk", 14, 0),
            new Player("Lukasz Sekulski", "Wisla Plock", 13, 3),
            new Player("Patryk Szysz", "Zaglebie Lubin", 11, 5),
            new Player("Luka Zahovic", "Pogon Szczecin", 11, 5),
            new Player("Muris Mesanovic", "Bruk-Bet Termalica Nieciecza", 11, 2),
            new Player("Erik Expósito", "Slask Wroclaw", 11, 2),
            new Player("Bartosz Spiaczka", "Gornik Leczna", 11, 0),
            new Player("Flávio Paixão", "Lechia Gdansk", 10, 7),
            new Player("Jakub Kaminski", "Lech Poznan", 9, 8),
            new Player("Vladislavs Gutkovskis", "Rakow Czestochowa", 9, 6),
            new Player("Kamil Grosicki", "Pogon Szczecin", 9, 6),
            new Player("Lukas Podolski", "Górnik Zabrze", 9, 4),
            new Player("Krzysztof Kubica", "Górnik Zabrze", 9, 3),
            new Player("Piotr Wlazlo", "Bruk-Bet Termalica Nieciecza", 9, 2),
            new Player("Adam Zrelak", "Warta Poznan", 9, 2),
            new Player("Jesús Imaz", "Jagiellonia Bialystok", 9, 2),
            new Player("Tomas Pekhart", "Legia Warszawa", 9, 1),
            new Player("Bartosz Nowak", "Górnik Zabrze", 8, 4),
            new Player("Jesús Jiménez", "Górnik Zabrze", 8, 4),
            new Player("Grzegorz Tomasiewicz", "Stal Mielec", 8, 2),
            new Player("Pelle van Amersfoort", "Cracovia", 8, 1)
    ));
}

````

---

### **1. `uniqueTeams` 함수 구현**

**문제 설명**: `uniqueTeams` 함수는 최소한 한 명의 선수를 보유한 팀의 수를 반환해야 합니다. 

즉, **중복되지 않는 팀의 수**를 구해야 합니다.

#### 해결 방법:

- `Player` 리스트에서 각 선수의 **팀 이름**을 추출하고, 이를 **중복되지 않게 저장**해야 합니다.

- **중복을 제거**하기 위해 **`distinct()`** 메서드를 사용할 수 있습니다.

#### 코드:

```java

public static long uniqueTeams(List<Player> players) {
    return players.stream()
                  .map(Player::getTeam)  // 각 선수의 팀 이름을 추출
                  .distinct()            // 중복을 제거
                  .count();              // 고유한 팀의 수를 세기
}
```

------

### **2. `topThreeAssists` 함수 구현**

**문제 설명**: `topThreeAssists` 함수는 **어시스트가 가장 많은 상위 3명의 선수**를 반환해야 합니다.

#### 해결 방법:

- `Player` 리스트를 **어시스트 순서대로 정렬**한 후, **상위 3명**을 추출합니다.
- **`sorted()`**로 정렬한 후 **`limit(3)`**로 상위 3명을 선택합니다.

#### 코드:

```java

public static List<Player> topThreeAssists(List<Player> players) {
    return players.stream()
                  .sorted(Comparator.comparingInt(Player::getAssists).reversed())  // 어시스트 수로 내림차순 정렬
                  .limit(3)  // 상위 3명 선택
                  .collect(Collectors.toList());  // 리스트로 변환
}
```

------

### **3. `mostCommonFirstName` 함수 구현**

**문제 설명**: `mostCommonFirstName` 함수는 **이름이 2번 이상 등장하는 가장 흔한 선수의 이름(성 포함)**을 반환해야 합니다.

#### 해결 방법:

- 선수의 **이름에서 첫 번째 이름(성)**을 추출한 후, **이름별로 몇 번 등장하는지 카운팅**합니다.
- **두 번 이상 등장하는 이름**만 필터링하여 반환합니다.

#### 코드:

```java

public static List<String> mostCommonFirstName(List<Player> players) {
    return players.stream()
                  .map(player -> player.getName().split(" ")[0])  // 이름에서 첫 번째 단어(성)만 추출
                  .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))  // 이름별로 카운팅
                  .entrySet().stream()
                  .filter(entry -> entry.getValue() >= 2)  // 2번 이상 등장하는 이름만 필터링
                  .map(Map.Entry::getKey)  // 이름 추출
                  .collect(Collectors.toList());  // 리스트로 변환
}
```

------

### **4. `teamsWithBestScoringPlayers` 함수 구현**

**문제 설명**: `teamsWithBestScoringPlayers` 함수는 각 팀의 선수가 **최소 2명 이상** 포함된 팀과 **그 팀의 선수 수**를 반환해야 합니다.

#### 해결 방법:

- `Player` 리스트를 팀별로 **그룹화**하고, 팀별로 **몇 명의 선수가 있는지 카운팅**한 후, **2명 이상 있는 팀**만 필터링합니다.
- 결과를 **팀 이름과 선수 수**가 포함된 리스트로 변환합니다.

#### 코드:

```java

public static List<Map.Entry<String, Long>> teamsWithBestScoringPlayers(List<Player> players) {
    return players.stream()
                  .collect(Collectors.groupingBy(Player::getTeam, Collectors.counting()))  // 팀별로 그룹화하고 카운팅
                  .entrySet().stream()
                  .filter(entry -> entry.getValue() >= 2)  // 2명 이상 있는 팀 필터링
                  .sorted(Map.Entry.<String, Long>comparingByValue().reversed())  // 선수 수로 내림차순 정렬
                  .collect(Collectors.toList());  // 리스트로 변환
}
```

------

### **5. `bestScoringTeam` 함수 구현**

**문제 설명**: `bestScoringTeam` 함수는 **가장 많은 골을 기록한 팀**을 반환해야 합니다.

#### 해결 방법:

- `Player` 리스트를 팀별로 **그룹화**하고, 각 팀의 총 골 수를 **더합니다**.
- 가장 높은 골 수를 가진 팀을 반환합니다.

#### 코드:

```java

public static Map.Entry<String, Integer> bestScoringTeam(List<Player> players) {
    return players.stream()
                  .collect(Collectors.groupingBy(Player::getTeam, Collectors.summingInt(Player::getGoals)))  // 팀별로 그룹화하고 골 수 더하기
                  .entrySet().stream()
                  .max(Map.Entry.comparingByValue())  // 가장 높은 골 수를 가진 팀 찾기
                  .orElse(null);  // 값이 없을 경우 null 반환
}
```

------

### **정리**

- **Streams API**를 통해 **데이터 처리 작업을 선언적으로 수행**할 수 있습니다.
- 각각의 문제는 `Stream`을 사용해 **데이터 필터링, 그룹화, 정렬 및 집계**를 간결하게 해결할 수 있습니다.
- 이러한 **함수형 프로그래밍 스타일**은 복잡한 로직을 더 **읽기 쉽고 유지보수하기 쉬운 코드**로 바꿀 수 있습니다.

이 코드를 실행하면 요구된 기능들이 처리되어 올바른 결과를 출력할 것입니다.

---

## 사용된 메서드 정리

| 메서드                 | 설명                                                         | 사용 예시                                                |
| ---------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| **`filter()`**         | 조건에 맞는 요소들만 걸러냅니다.                             | `stream.filter(x -> x > 10)`                             |
| **`map()`**            | 스트림의 각 요소를 변환합니다.                               | `stream.map(x -> x * 2)`                                 |
| **`distinct()`**       | 중복을 제거하고 고유한 요소들만 남깁니다.                    | `stream.distinct()`                                      |
| **`sorted()`**         | 스트림을 정렬합니다.                                         | `stream.sorted()`                                        |
| **`limit()`**          | 스트림의 처음부터 지정한 수만큼 요소를 가져옵니다.           | `stream.limit(5)`                                        |
| **`skip()`**           | 스트림의 처음 지정한 수만큼 요소를 건너뜁니다.               | `stream.skip(3)`                                         |
| **`collect()`**        | 스트림의 데이터를 원하는 형식으로 변환하거나 수집합니다.     | `stream.collect(Collectors.toList())`                    |
| **`count()`**          | 스트림의 요소 수를 셉니다.                                   | `stream.count()`                                         |
| **`forEach()`**        | 스트림의 각 요소에 대해 작업을 수행합니다.                   | `stream.forEach(System.out::println)`                    |
| **`reduce()`**         | 스트림의 요소들을 결합해 하나의 결과를 만듭니다.             | `stream.reduce(0, Integer::sum)`                         |
| **`flatMap()`**        | 각 요소를 스트림으로 변환하고, 이를 하나의 스트림으로 병합합니다. | `stream.flatMap(List::stream)`                           |
| **`anyMatch()`**       | 스트림의 요소 중 적어도 하나가 조건을 만족하는지 확인합니다. | `stream.anyMatch(x -> x > 10)`                           |
| **`allMatch()`**       | 스트림의 모든 요소가 조건을 만족하는지 확인합니다.           | `stream.allMatch(x -> x > 10)`                           |
| **`noneMatch()`**      | 스트림의 모든 요소가 조건을 만족하지 않는지 확인합니다.      | `stream.noneMatch(x -> x > 10)`                          |
| **`findFirst()`**      | 스트림의 첫 번째 요소를 반환합니다.                          | `stream.findFirst()`                                     |
| **`findAny()`**        | 스트림에서 임의의 요소를 반환합니다.                         | `stream.findAny()`                                       |
| **`max()`**            | 스트림의 최대값을 찾습니다.                                  | `stream.max(Comparator.naturalOrder())`                  |
| **`min()`**            | 스트림의 최소값을 찾습니다.                                  | `stream.min(Comparator.naturalOrder())`                  |
| **`groupingBy()`**     | 요소들을 특정 기준으로 그룹화합니다.                         | `stream.collect(Collectors.groupingBy(Player::getTeam))` |
| **`partitioningBy()`** | 조건을 기준으로 두 개의 그룹으로 나눕니다.                   | `stream.collect(Collectors.partitioningBy(x -> x > 10))` |

### **메서드 설명**

- **`filter()`**: 주어진 조건을 만족하는 요소만 걸러냅니다. 데이터 필터링에 자주 사용됩니다.
- **`map()`**: 각 요소를 특정 방식으로 변환하는 데 사용됩니다. 데이터 가공에 필수적입니다.
- **`distinct()`**: 중복된 데이터를 제거합니다. 데이터의 고유성을 유지하고자 할 때 사용됩니다.
- **`sorted()`**: 데이터를 오름차순 또는 내림차순으로 정렬할 수 있습니다.
- **`collect()`**: 스트림을 리스트, 맵 등의 자료구조로 변환합니다. 최종 처리에 자주 사용됩니다.
- **`count()`**: 스트림에 있는 요소의 개수를 셉니다.
- **`forEach()`**: 스트림의 각 요소에 대해 작업을 수행할 때 사용됩니다. 주로 출력을 위한 용도로 사용됩니다.
- **`reduce()`**: 스트림의 모든 요소를 하나의 값으로 합칩니다. 합계나 곱 등을 계산할 때 유용합니다.
- **`flatMap()`**: 다중 리스트나 배열 등을 하나의 리스트로 병합하는 데 사용됩니다.
- **`groupingBy()`**: 데이터를 그룹화할 때 사용됩니다. 특정 기준에 따라 데이터를 묶는 데 유용합니다.

### **주요 메서드 요약**:

- **필터링 및 변환**: `filter()`, `map()`, `distinct()`
- **정렬 및 제한**: `sorted()`, `limit()`, `skip()`
- **최종 처리**: `collect()`, `count()`, `forEach()`
- **집계 및 합계**: `reduce()`, `groupingBy()`
- **일치 여부 확인**: `anyMatch()`, `allMatch()`, `noneMatch()`

---





