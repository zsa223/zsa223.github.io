---
title: Prog Tut05 
date: 2024-09-07 14:20:00 +0200
categories: [Prog, Tut05]
tags: [Prog]
render_with_liquid: false
typora-root-url: ../
---



## Lambda - Ausdrücke



|           Lambda -Ausdruck (Java)            | Funtionales Interface                                 | Lambda-Ausdruck (Scala)               |
| :------------------------------------------: | ----------------------------------------------------- | ------------------------------------- |
|                 (x) -> x +1                  | Function \<T, R>  <br />UnaryOperator\<T>  <br />     | (x : Int )  =>  x+1                   |
|              (x) -> x % 2 == 1               | Predicate\<T>                                         | (x: Int) => x % 2 == 1                |
|             () -> r.nextInt(100)             | Supplier\<Integer>                                    | () => r.nextInt(100)                  |
| (s) -> System.out.println( s.toLowerCase() ) | Consumer\<String>                                     | (s: String) => println(s.toLowerCase) |
|            (s) -> s.toLowerCase()            | Function<String, String><br /> UnaryOperator\<String> | (s: String) => s.contains(Ä")         |
|               (s) -> s + ", "                | Function<String, String> <br />UnaryOperator\<String> | (s: String) => s + ", "               |
|                      -                       | -                                                     | -                                     |

---



### 1. `Funtion<T, R>`  : Funktion, die die Eingabe T annimmt und R zurückgibt.

***Methode : R apply ( T t )***

z.B : `Function< Interger, String >` : 인트를 받아가 스트링으로 내뱉는거지. 주로 입력받은 값을 가공할때 사용

---

### 2. `UnaryOperatro<T>` : Nimmt denselben Typ an und gibt denselben Typ zurück.

***Methode : R apply ( T t )***

z.b : `UnaryOperator<Interger> f = x-> x+1` :  인트를 받아가 그 값을 하나 증가시킴

---

### 3. `Predicate<T>` : Eingabe T nehmen und Ture or False  bestimmen.

***Methode : Boolean test (T t)***

z.b : `(x: Int) = x % 2 == 1 ` : 짝수냐 홀수냐 ? 

---

### 4.  `Supplier<T>` : ohne Eingabe Wert, Gibt das Ergebnis T zurück.

***Methode : T get (  )*** 

z.b. : `( ) => r.nextInt(100)` : 0~99까지 난수를 생성해서 반환. 값을 받지 않는것이 포인트. 비어있음. (  )  

---

### 5. `Consumer<T>` :  nur Eingabewert,  No return .

***Methode : void accept ( T t )***

z.b : `(s:String)=> println(s.toLowerCase() )` : 입력받은 문자를 출력. 입력을 받고 특정 작업을 수행.

---



## Was sind 'Primitive Specializations' ? 

## Warum gibt es sie und Wann sollte man sie verwenden ?

- Primitive Specializations sind funktionale Interfaces, die **nur auf primitiven Datentypen basieren**  und **Autoboxing nicht zulassen**
- 프리미티브 전문화는 프리미티브 데이터 유형만을 기반으로 하며 자동 박싱을 허용하지 않는 기능적 인터페이스입니다.

---

**Warum ?** : Generic Typ können primitive Typen nicht direkt verwenden, sondern müssen in einen Ref.typ konvertiert werden. z.b `int -> Integer` muss konvertiert werden.

**Wann ?** : Aktiviert zur Leistungs-Optimierung. Reduzieren Sie die Speichernutzung. 

---

## Was ist der Unterschied zwischen Function und UnaryOperator?

- **Function<T, R>**: **입력 타입**(T)과 **출력 타입**(R)이 **다를 수 있는 함수형 인터페이스**입니다. 

Funktionale Interface, die verschiedene Eingabetypen (T) und Ausgabentypen (R) haben kann

예: `Function<Integer, String>`.

- **UnaryOperator\<T>**: **입력 타입과 출력 타입이 동일한 경우** 사용되는 함수형 인터페이스입니다. 

Eingang und Ausgang müssen identisch sein.

즉, `Function<T, T>`의 특수화 버전입니다.

- **차이점**: `Function`은 **입력과 출력의 타입이 다를 수 있지만**, `UnaryOperator`는 **항상 동일한 타입의 값**을 반환합니다.

---

## **Predicate vs Function in filter()**

- **Predicate\<T>** :  **입력값을 받아 참(True) 또는 거짓(False)을 반환**하는 함수형 인터페이스. 

`boolean test(T t)` 메서드를 사용합니다.

- **Function<T, R>**:  입력값을 받아 **임의의 값을 반환**하는 함수형 인터페이스. 

`R apply(T t)` 메서드를 사용합니다.

- **차이점**: `filter()`는 **Predicate**를 사용해 내부적으로 **`test()`** 메서드를 호출합니다. 
- `Function`은 **`apply()`** 메서드만을 가지고 있어 직접적으로 `Predicate`의 역할을 할 수 없습니다. 
- `filter()`에는 반드시 **Predicate**가 필요합니다.







---

### 햇갈렸던 문법 정리

1. "->" 는 자바에서 사용하는 람다 표현식 문법

   (매개변수) -> { 함수의 본문 } 으로 구성 

   `BiPredicate<Integer, Integer> bp = (x, y) -> x.equals(y);`

   

2. "=>" 는 스칼라에서 사용되는 람다 표현식

   (매개변수) => { 함수의 본문 }으로 구성

   예) val sum = (x: Int, y: Int) => x + y 
   
   ---
   
   
