---
title: Prog Tut08
date: 2024-09-16 10:00:00 +0200
categories: [Prog, Tut08]
tags: [Prog]
render_with_liquid: false
typora-root-url: ../




---

# Futures, Thread, Case Klassen, Companion Objekt.



---

**Thread와 Future의 차이점에 대한 상세 설명**

1. **Thread**

   - **실행 단위**: Thread는 프로세스 내에서 독립적으로 실행되는 가장 작은 실행 단위입니다. 하나의 애플리케이션에서 여러 Thread를 사용하면 동시에 여러 작업을 수행할 수 있습니다.
   - **반환값 없음**: 일반적으로 Thread는 실행 후 직접적인 반환값을 제공하지 않습니다. 결과를 얻기 위해서는 공유 변수나 콜백 메서드를 사용해야 합니다.
   - **생성과 관리의 복잡성**: Thread를 직접 생성하고 관리하려면 `Thread` 클래스를 상속하거나 `Runnable` 인터페이스를 구현해야 합니다. 이는 코드의 복잡성을 증가시키고, 동기화 이슈를 일으킬 수 있습니다.
   - **동기화 필요**: 여러 Thread가 공유 자원에 접근할 때는 동기화(synchronization)를 적절히 처리해야 데이터 불일치나 레이스 컨디션을 방지할 수 있습니다.

2. **Future**

   - **비동기 계산의 결과 표현**: Future는 비동기적으로 실행되는 계산의 예상 결과를 나타냅니다. 계산이 완료되면 결과를 제공합니다.
   - **반환값 존재**: `Future[T]`의 형태로, 특정 타입 `T`의 결과를 반환합니다. 이는 비동기 작업의 결과를 손쉽게 다룰 수 있게 해줍니다.
   - **Thread 풀 사용**: Future는 내부적으로 Thread 풀(execution context)을 활용하여 작업을 수행하므로, **개발자가 직접 Thread를 관리할 필요가 없습니다.**
   - **함수형 프로그래밍 지원**: `map`, `flatMap`, `filter` 등과 같은 고차 함수를 지원하여, 비동기 작업의 결과를 변환하거나 조합할 수 있습니다.
   - **에러 처리 용이**: Future는 성공과 실패를 모두 처리할 수 있으며, `onComplete`, `onSuccess`, `onFailure`와 같은 메서드를 통해 결과에 대한 콜백을 지정할 수 있습니다.
   - **논블로킹 방식**: Future를 사용하면 메인 Thread를 블로킹하지 않고도 비동기 작업을 수행하고 결과를 처리할 수 있습니다.

3. **Scala에서의 Future 사용**

   - **선언적 코드 작성**: Future를 사용하면 비동기 작업을 더욱 선언적으로 표현할 수 있어 코드의 가독성이 향상됩니다.
   - **조합성**: 여러 Future를 조합하여 복잡한 비동기 로직을 구성할 수 있습니다. 예를 들어, 여러 비동기 작업을 순차적으로 또는 병렬로 실행하고 그 결과를 결합할 수 있습니다.
   - **예외 전파**: Future 내부에서 발생한 예외는 자동으로 전파되며, 이를 통해 에러 처리를 체계적으로 할 수 있습니다.

4. **API 차이점**

   - **Thread API**: Thread는 주로 `start()`, `run()`, `join()` 등의 메서드를 사용하며, 낮은 수준의 제어를 제공합니다.
   - **Future API**: Future는 **고차 함수와 콜백 메서드를 제공**하여, 비동기 작업을 고수준에서 다룰 수 있습니다.

5. **코드 예제**

   - Thread 예제

     :

     ```scala
     val thread = new Thread(new Runnable {
       def run(): Unit = {
         println("Thread 실행 중")
       }
     })
     thread.start()
     ```

   - Future 예제

     :

     ```scala
     val futureResult = Future {
       // 시간이 오래 걸리는 계산
       Thread.sleep(1000)
       42
     }
     
     futureResult.onComplete {
       case Success(value) => println(s"결과: $value")
       case Failure(exception) => println(s"에러: ${exception.getMessage}")
     }
     ```

6. **동시성과 병렬성에서의 활용**

   - **Thread의 한계**: Thread를 직접 관리하면 복잡성과 오류 가능성이 높아집니다. 특히 많은 수의 Thread를 생성하면 오버헤드가 커집니다.
   - **Future의 장점**: Future는 Thread 풀을 사용하여 자원을 효율적으로 관리하고, 비동기 작업을 쉽게 조합할 수 있습니다.

7. **시험 출제 가능성**

   - **중요 개념**: Thread와 Future의 차이점은 동시성(concurrency)과 비동기 프로그래밍에서 핵심적인 개념입니다.
   - **출제 예상**: 이론적인 차이뿐만 아니라, 실제 코드에서의 적용 방법, 장단점, 사용 시 주의사항 등에 대한 문제가 나올 수 있습니다.
   - **준비 방법**: 두 개념의 원리, 사용 방법, 그리고 실용적인 사례를 공부하고, 직접 코드를 작성해 보는 것이 좋습니다.

**결론적으로**, Thread와 Future는 모두 동시에 여러 작업을 처리하기 위한 도구이지만, 추상화 수준과 사용 방법에서 큰 차이가 있습니다. Future를 사용하면 비동기 작업을 보다 안전하고 효율적으로 관리할 수 있으며, Scala에서는 Future를 활용한 비동기 프로그래밍이 일반적입니다.



---

**2. Future의 `value` 메서드 호출이 반환할 수 있는 가능한 반환 타입**

Scala에서 모든 `Future[T]`는 현재 Future의 상태를 나타내는 `value`라는 메서드를 가지고 있습니다. 이 메서드는 `Option[Try[T]]` 타입의 값을 반환합니다. 반환 가능한 세 가지 경우는 다음과 같습니다:

- **`None`**: Future가 아직 완료되지 않았습니다. 계산이 진행 중이며 결과가 아직 제공되지 않았습니다.
- **`Some(Success[T])`**: 계산이 성공적으로 완료되었으며, 결과는 타입 `T`입니다. `Success` 객체는 계산된 값을 포함합니다.
- **`Some(Failure[Throwable])`**: 계산 중 예외가 발생했습니다. `Failure` 객체는 예외를 설명하는 `Throwable`을 포함합니다.

**설명:**

- **`Option`**: Future가 아직 완료되지 않았을 수 있으므로 결과를 `Option`으로 감쌉니다.
- **`Try`**: 계산 결과는 성공한 값(`Success`)이거나 예외(`Failure`)일 수 있습니다.

**예제:**

```scala
val futureValue = Future {
  // 어떤 계산
  42
}

// Future의 상태 확인
futureValue.value match {
  case None => println("계산이 아직 진행 중입니다.")
  case Some(Success(result)) => println(s"계산 성공: $result")
  case Some(Failure(exception)) => println(s"계산 실패: ${exception.getMessage}")
}
```

3. **Await는 future의 결과를 기다리는 데 사용될 수 있습니다. 비동기 계산의 관점에서 단점은 무엇입니까?**

Await은 호출 스레드를 차단합니다. 이 경우 동일한 스레드에서 계산을 실행하여 시간을 절약할 수도 있었을 것입니다.

---



**4. Erstellen Sie einen benutzerdefinierten ExecutionContext, der nur einen Thread für Futures bereitstellt.**

````scala
import scala.concurrent._
import java.util.concurrent.Executors

// ExecutionContext erstellen
val executorService = Executors.newFixedThreadPool(1)
val executionContext = ExecutionContext.fromExecutorService(executorService)
````



### 1. **ExecutionContext**란 무엇인가?

`ExecutionContext`는 **비동기 작업이 실행되는 환경**을 정의하는 추상화입니다. 쉽게 말해, `Future`나 다른 비동기 코드가 실행될 때 어떤 스레드 풀에서 실행될지를 관리합니다. 

이 `ExecutionContext`는 비동기 작업을 병렬로 실행할 수 있게 도와주는 역할을 하며, 스레드를 효율적으로 사용하기 위해 필요합니다.

기본적으로 Scala에는 전역적으로 사용할 수 있는 `ExecutionContext.global`이 있지만, 특정한 요구에 맞게 사용자 정의 `ExecutionContext`를 만들 수 있습니다. 이 코드에서는 **하나의 스레드만 사용**하도록 설정한 `ExecutionContext`를 정의합니다.

### 2. **`Executors.newFixedThreadPool(1)` 사용**

```scala
val executorService = Executors.newFixedThreadPool(1)
```

여기서 `Executors.newFixedThreadPool(1)`은 **Java의 ExecutorService**를 사용하여 고정된 크기의 스레드 풀을 생성하는 코드입니다. 이 예제에서는 `1`을 인자로 전달했으므로, **하나의 스레드만 사용할 수 있는 스레드 풀**을 생성하게 됩니다.

- `FixedThreadPool`은 정해진 개수의 스레드가 사용되며, 작업이 많을 경우 스레드 수 이상으로 동시에 실행되지 않습니다.
- 즉, 이 스레드 풀은 한 번에 하나의 작업만 실행할 수 있으며, 나머지 작업들은 해당 스레드가 사용 가능해질 때까지 대기하게 됩니다.

### 3. **`ExecutionContext.fromExecutorService` 사용**

```scala
val executionContext = ExecutionContext.fromExecutorService(executorService)
```

`ExecutionContext.fromExecutorService`는 **Java의 `ExecutorService`를 받아서** Scala의 `ExecutionContext`로 변환하는 역할을 합니다. 즉, 앞서 정의한 고정 크기 스레드 풀을 사용하여 **하나의 스레드만 사용하는 `ExecutionContext`**를 만들게 됩니다.

- `ExecutionContext`는 `Future`가 실행될 스레드를 관리하는 데 사용됩니다. 이 예시에서는 하나의 스레드만 사용하도록 설정되었기 때문에, **모든 비동기 작업이 하나의 스레드에서 차례로 실행**됩니다.

### 4. **왜 하나의 스레드만 사용하는가?**

이 코드는 **단일 스레드로 제한된 환경에서 실행되는 비동기 작업**을 만들고 싶을 때 유용합니다. 예를 들어, 스레드 안전성을 위해 여러 작업이 동시에 실행되지 않도록 할 때나, 순차적으로 실행해야 하는 작업들을 처리할 때 사용할 수 있습니다.

하나의 스레드만 사용하는 상황의 예시:

- **경쟁 상태(Race condition)**를 방지하고 싶을 때: 비동기 작업들이 동시에 실행되면 상태를 공유하는 경우 문제가 발생할 수 있으므로, 하나의 스레드에서만 작업을 실행하여 이러한 문제를 피할 수 있습니다.
- **자원 제약이 있는 시스템**에서 스레드 사용을 최소화하고 싶을 때: 스레드 풀의 크기를 줄이면 자원을 더 효율적으로 사용할 수 있습니다.

### 전체 코드 요약

```scala
// 1. 스레드 풀을 1개의 스레드로 고정하여 생성
val executorService = Executors.newFixedThreadPool(1)

// 2. 이 스레드 풀을 사용하여 ExecutionContext 생성
val executionContext = ExecutionContext.fromExecutorService(executorService)
```

이 코드는 **하나의 스레드만 사용하는 `ExecutionContext`**를 설정하여, 비동기 작업이 순차적으로 하나씩 실행되도록 보장하는 방식입니다. 스레드 안전성을 유지하면서 자원을 절약하거나 작업의 순서를 보장해야 할 때 유용합니다.

이 방식은 `Future`를 사용할 때, 어떤 작업들이 동시에 실행되지 않고 **순차적으로 실행**되어야 하는 경우에 적합합니다.

























